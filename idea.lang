def Hash_Map<T: type, U: type> = struct {
	t: T,
	u: U
};

def String_Hash_Map<U: type> = Hash_Map(<string, U>);

var x: Hash_Map(<uint, uint>);
insert(&x, 4, 5);

insert(<uint, uint>)(&x, 4, 5);

// Advantages: good
// Disadvantages: how to deduce types?
def insert<T: type, U: type> = fn(map: *Hash_Map(<T, U>), t: T, u: U) -> {
	
};

def insert<T: type> = fn(map: *T, t: key_type(T), u: value_type(T)) -> {
	assert(follows(T, Hash_Map(<void, void>)));
};

def key_type = fn(T: type): type -> type_info(T).struct_.items[0].type;

def insert<T: type; follows(T, Hash_Map(<void, void>)) && foo(T)> = fn(map: *T, t: key_type(T), u: value_type(T)) -> {
	run assert(follows(T, Hash_Map(<void, void>)));
};

def main = fn() {
	var map: Hash_Map(<uint, uint>);
	insert(&map, 4, 5);
};

def Foo1<T: type> = struct {
	t: T
};

def Foo2<T: type> = fn() type {
	return struct {
		t: T,
	};
};

def Foo1_uint = Foo1(<uint>);
def Foo2_uint = Foo2(<uint>)();

// ----

def String = *[]byte;

def String2 = fn() {
	return String; // depends on value of String
};

def Foo = struct {
	a: String2() // depends on value of String2
};

def bar = fn() {
	var foo: Foo; // depends on value of Foo
	baz(); // depends on type of bar
};

def baz = fn() {
	bar(); // depends on type of bar
};

def X = mod {
};

def Y = import("test");

def x = fn() {
};

def X = mod {
	def foo = x; // depends X
};

X.print // depends X

def foo = fn(): uint -> {
	var a = {
		var b = 1 + 1;
		if foo() {
			yield b; // break out of the block
		};
	};
	// a = 2

	while true {
		while true {
			if foo() {
				break a;
			}
			if bar() {
				continue;
			}
		};
	};
};

// -----

def x = mod {
	def foo = fn() -> {
	};
};

def bar = fn() -> {
	x::foo();
};
















def Map = struct<T: type, U: type> {
};

def StringMap = generic<U: type> Map(<String, U>);


def put = fn<T: type; follows(T, Map)>(map: T, ) -> {
};














def print$(fmt: string, T..: type) = fn(args: T..) -> {

};

print#("%\n")(value);
print(<"%\n">)(value);

def print$(fmt: string, T..: type) = fn(fmt: string, args: T..) -> {

};

print("%\n", value);

def foo#(X: type) = fn(foo: Foo$(X), x: X) {
};

var foo_var: Foo$(uint32);
// Foo$(uint32), uint
foo(foo_var, 4);


def get = fn() bool, uint {
	return true, 4;
};

var x, y = get();

x, y = 4, 3;




def get#(T: type) = fn(): ?T {
};

var x: ?uint = null;
x? = 4;
var y = x?;
if x?? {
	var z: uint = xv;
}





def a = fn(): uint {
	var c = a: {
		var b = 4;
		if foo() {
			yield@a b;
		};

		// need a yield here
		yield b;
	};
	return x;
};





def identity#(T: type) = fn(t: T) {
	yield t;
}

def identity = gen(T: type) fn(t: T) {
	yield t;
}

def identity = fn(t: $T) {
	yield t;
}

def identity = #(T: type) fn(t: T) {
	yield t;
}

def foo = #(T: type, U: type) struct {
	a: T,
	b: U
};

def bar = #(T: type) foo#(T, uint);

// Upsides, generic things can be values on their own
def main = fn() {
	var a: bar#(uint);
	var b = identity(a);
};

def slice = mod {
	// Generic(Operator(Struct))
	def slice = #(T: type) struct {
		len: uint,
		ptr: ^[]T,
	} op {
		[] = fn(slice: ^slice#(T), index: uint): ^T {
			yield &slice.ptr[index];
		},
		slice = fn(slice: slice#(T), start: uint, end: uint): slice#(T) {
			yield .{ end - start, &slice.ptr[start] };
		}
	};

	def new = #(T: type, U: type) fn(array: ^[U]T): slice#(T) {
		yield .{ U, array };
	};
};

def A = #(T: type) mod {
	def B = #(U: type) struct {
		t: T,
		u: U
	};
};

var x: A#(uint)::B#(uint);
var y: A#(str)::B#(uint) = x; // should be invalid

var x = slice::new(&array);
// Instead of checking the define data of the type, can use the type directly
x[4] = 5;

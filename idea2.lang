def Tagged_Union$(Tag_Type: type, Union: type) = struct {
	tag: Tag_Type,
	data: Union
};

def Node = Tagged_Union$(uint, union {
	a: uint,
	b: uint
});

def slice$(T: type) = struct {
	len: uint,
	ptr: ^[]T,
};

def a = fn(): struct { a: uint, b: uint } {
}

def slice_create$(T: type, U: type) = fn(array: ^[U]T): slice$(T) {
	return .{ T, array };
};

def Node = union(uint, union {
	a: uint,
	b: uint
});

slice_create("test");

def switch_test = fn(check: Ast_Node, branches: slice(<Ast_Node>)) -> {
	Node *node = new(.{ .switch_ = .{ .check = check, .branches = branches } });
};

#insert switch_test(#ast x.tag, slice_create([_]Ast_Node{#ast print("is an a")}));

fn expand_switch = fn(switch_node: Ast_Node) -> {

};

var x: Node;
expand_switch(switch x {
	a => |a| print("is an a with value ", a),
	b => |b| print("is an b with value ", a),
});

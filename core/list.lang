def allocate = import("allocate.lang");
def c = import("c.lang");

def List = fn (static T: type): type {
	return struct {
		items: ^[_]T,
		length: uint,
		capacity: uint,
		allocator: allocate::Allocator;

		op add = fn (list: ^self, element: T): void!allocate::Allocate_Error {
			if list.length == list.capacity {
				list.capacity = list.capacity * 2;

				if list.capacity == 0 => list.capacity = 1;

				list.items = list.allocator:realloc(list.items, list.capacity * run size_of(T)) catch |err| {
					return!! err;
				};
			};

			list.items[list.length] = element;
			list.length = list.length + 1;

			return! .{};
		};

		op to_array_view = fn (list: ^self): []T {
			var result: []T;
			result.len = list.length;
			result.ptr = list.items;
			return result;
		};

		op get = fn (list: ^self, index: uint): T {
			list.items[index]
		};

		op [] = fn (list: ^self, index: uint): ^T {
			&list.items[index]
		};
	}
};

def new = fn (static T: type, allocator: allocate::Allocator): List(T) {
	.{ null, 0, 0, allocator }
};

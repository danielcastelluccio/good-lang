def List = fn (T: type): type {
	return struct {
		items: ^[_]T,
		length: uint,
		capacity: uint,
		allocator: allocate::Allocator;

		op add = fn (list: ^self, element: T): !allocate::Allocate_Error {
			if list.length == list.capacity {
				var new_capacity = list.capacity * 2;
				if new_capacity == 0 => new_capacity = 1;

				list.items = cast(^[_]T) list.allocator:realloc(cast(^) list.items, new_capacity * size_of(T)) catch |error| {
					return err(error);
				};

				list.capacity = new_capacity;
			};

			list.items[list.length] = element;
			list.length = list.length + 1;

			return ok();
		};

		op to_array_view = fn (list: ^self): []T {
			var result: []T;
			result.len = list.length;
			result.ptr = list.items;
			return result;
		};

		op get = fn (list: ^self, index: uint): T {
			list.items[index]
		};

		op free = fn (list: ^self) {
			list.allocator:free(cast(^) list.items);
		};

		op [] = fn (list: ^self, index: uint): ^T {
			&list.items[index]
		};
	};
};

def new = fn (static T: type, allocator: allocate::Allocator): List(T) {
	.{ null, 0, 0, allocator }
};

def allocate = import("allocate.lang");
def c = import("c.lang");

def Allocate_Error = enum {
	OUT_OF_MEMORY
};

def Allocate_Mode = enum {
	ALLOC,
	REALLOC,
	FREE
};
def Allocate_Fn = fn (mode: Allocate_Mode, ptr: ^, size: uint): ^!Allocate_Error;

def Allocator = struct {
	allocate_fn: Allocate_Fn;

	op new = fn (allocator: ^Allocator, static T: type): ^T!Allocate_Error {
		cast(^T!Allocate_Error) allocator.allocate_fn(ALLOC, null, size_of(T))
	};

	op realloc = fn (allocator: ^self, ptr: ^, size: uint): ^!Allocate_Error {
		allocator.allocate_fn(REALLOC, ptr, size)
	};

	op free = fn (allocator: ^self, ptr: ^) {
		allocator.allocate_fn(FREE, ptr, 0)
	};
};

def C_Allocator = struct {
	op allocator = fn (_: ^self): Allocator {
		return .{ c_allocator_allocate };
	};
};

// Do not modify, is a global so a pointer can be taken.
def* c_allocator = global: C_Allocator => .{};

def c_allocator_allocate = fn (mode: Allocate_Mode, ptr: ^, size: uint): ^!Allocate_Error {
	switch mode {
		case ALLOC => {
			if c::malloc(size) |ptr| {
				return ok(ptr);
			} else {
				return err(OUT_OF_MEMORY);
			};
		}
		case REALLOC => {
			if c::realloc(ptr, size) |ptr| {
				return ok(ptr);
			} else {
				return err(OUT_OF_MEMORY);
			};
		}
		case FREE => {
			c::free(ptr);
			return ok(null);
		}
	};
};

def c = import("c.lang");

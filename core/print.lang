def Output_Fn = fn (data: ^, char: byte);

def Printer = struct {
	output_fn: Output_Fn;

	op print = fn [T](printer: ^Printer, $fmt: []byte, args: T) {
		var$ type_info = type_info_of(T);
		if$ type_info is Tuple |tuple| {
			var$ argument_index: uint = 0;
			var$ i: uint = 0;
			while$ i < fmt.len {
				if$ fmt[i] == '{' {
					var$ start = i + 1;
					while$ fmt[i] != '}' {
						i =$ i + 1;
					};

					var$ end = i;

					if$ argument_index >= tuple.members.len {
						compile_error("Not enough arguments");
					};

					printer:print_value(embed("args._", cast(byte) argument_index + 48), fmt[start, end]);
					argument_index =$ argument_index + 1;
				} else {
					printer:print_char(fmt[i]);
				};
				i =$ i + 1;
			};
		} else {
			compile_error("Need tuple as argument");
		};
	};

	op print_value = fn [T](printer: ^Printer, t: T, $fmt: []byte) {
		var$ type_info = type_info_of(T);
		switch$ type_info {
			case Integer {
				var buffer: [24]byte;
				var index: uint = 24;

				var negative = t < 0;

				var i = t;
				if negative {
					i = 0 - i;
				};

				if i == 0 {
					index = index - 1;
					buffer[index] = '0';
				};

				while i > 0 {
					index = index - 1;

					var ch = i % 10 + 48;

					buffer[index] = cast(byte) ch;
					i = i / 10;
				};

				if negative {
					index = index - 1;
					buffer[index] = '-';
				};

				printer:print_chars(buffer[index, 24]);
			}
			case Byte {
				var buffer: [24]byte;
				var index: uint = 24;
				var i: uint = cast(uint) t;

				if i == 0 {
					index = index - 1;
					buffer[index] = '0';
				};

				while i > 0 {
					index = index - 1;

					var ch = i % 10 + 48;

					buffer[index] = cast(byte) ch;
					i = i / 10;
				};

				printer:print_chars(buffer[index, 24]);
			}
			case Pointer {
				if t == null {
					printer:print_chars("null");
				} else {
					var buffer: [24]byte;
					var index: uint = 24;
					var i: uint = cast(uint) t;
					while i > 0 {
						index = index - 1;

						var ch = i % 16;
						if ch > 9 => ch = ch + 87 else ch = ch + 48;

						buffer[index] = cast(byte) ch;
						i = i / 16;
					};

					printer:print_chars("0x");
					printer:print_chars(buffer[index, 24]);
				};
			}
			case Struct |struct_| {
				printer:print_chars(".{");
				for$ struct_.members |member, i| {
					printer:print_chars(" .");
					printer:print_chars(run member.name);
					printer:print_chars(" = ");

					printer:print_value(embed("t.", member.name), "");

					if$ i < struct_.members.len - 1 {
						printer:print_chars(",");
					} else {
						printer:print_chars(" ");
					};
				};
				printer:print_chars("}");
			}
			case Tagged_Union |tagged_union_| {
				printer:print_chars(".{");

				for$ tagged_union_.members |member| {
					if t is embed(member.name) |value| {
						printer:print_chars(run member.name);

						printer:print_value(value, "");
						printer:print_chars(" ");
					};
				};

				printer:print_chars("}");
			}
			case Enum |enum_| {
				for$ enum_.values |value| {
					if t == embed(value) {
						printer:print_chars(value);
					};
				};
			}
			case Optional {
				if t |value| {
					printer:print_value(value, "");
				} else {
					printer:print_chars("null");
				};
			}
			case Array |array| {
				printer:print_chars(".{");

				for$ 0..run array.size |i| {
					printer:print_chars(" ");

					printer:print_value(t[i], "");

					if i < run array.size - 1 {
						printer:print_chars(",");
					} else {
						printer:print_chars(" ");
					};
				};

				printer:print_chars("}");
			}
			case Array_View |array_view| {
				if$ fmt == "s" and array_view.type == byte {
					printer:print_chars(t);
				} else {
					printer:print_chars(".{");

					for 0..t.len |i| {
						printer:print_chars(" ");

						printer:print_value(t[i], "");

						if i < t.len - 1 {
							printer:print_chars(",");
						} else {
							printer:print_chars(" ");
						};
					};

					printer:print_chars("}");
				};
			}
			case Boolean {
				if t {
					printer:print_chars("true");
				} else {
					printer:print_chars("false");
				};
			}
		};
	};

	op print_char = fn (printer: ^Printer, char: byte) {
		printer.output_fn(null, char);
	};

	op print_chars = fn (printer: ^Printer, chars: []byte) {
		for chars |c| {
			printer.output_fn(null, c);
		};
	};
};

def Output_Fn = fn (data: ^, char: byte);

def Printer = struct {
	output_fn: Output_Fn;

	op print = fn [T](printer: ^Printer, static fmt: []byte, args: T) {
		var static type_info = type_info_of(T);
		if static type_info is Tuple |tuple| {
			var static argument_index = 0;
			var static i: uint = 0;
			while static i < fmt.len {
				if static fmt[i] == '{' {
					var static start = i + 1;
					while static fmt[i] != '}' {
						i =static i + 1;
					};

					var static end = i;

					var static format = fmt[start, end];
					printer:print_value(embed("args._", cast(byte) argument_index + 48), format);
					argument_index =static argument_index + 1;
				} else {
					printer:print_char(fmt[i]);
				};
				i =static i + 1;
			};
		} else {
			compile_error("Need tuple as argument");
		};
	};

	op print_value = fn [T](printer: ^Printer, t: T, static fmt: []byte) {
		var static type_info = type_info_of(T);
		switch static type_info {
			case Integer {
				var buffer: [24]byte;
				var index: uint = 24;

				var negative = t < 0;

				var i = t;
				if negative {
					i = 0 - i;
				};

				if i == 0 {
					index = index - 1;
					buffer[index] = '0';
				};

				while i > 0 {
					index = index - 1;

					var ch = i % 10 + 48;

					buffer[index] = cast ch;
					i = i / 10;
				};

				if negative {
					index = index - 1;
					buffer[index] = '-';
				};

				printer:print_chars(buffer[index, 24]);
			}
			case Byte {
				var buffer: [24]byte;
				var index: uint = 24;
				var i: uint = cast t;

				if i == 0 {
					index = index - 1;
					buffer[index] = '0';
				};

				while i > 0 {
					index = index - 1;

					var ch = i % 10 + 48;

					buffer[index] = cast ch;
					i = i / 10;
				};

				printer:print_chars(buffer[index, 24]);
			}
			case Pointer {
				if t == null {
					printer:print_chars("null");
				} else {
					var buffer: [24]byte;
					var index: uint = 24;
					var i: uint = cast t;
					while i > 0 {
						index = index - 1;

						var ch = i % 16;
						if ch > 9 => ch = ch + 87 else ch = ch + 48;

						buffer[index] = cast ch;
						i = i / 16;
					};

					printer:print_chars("0x");
					printer:print_chars(buffer[index, 24]);
				};
			}
			case Struct |struct_| {
				printer:print_chars(".{");
				for static struct_.members |member, i| {
					var static name = member.name;
					printer:print_chars(" .");
					printer:print_chars(name);
					printer:print_chars(" = ");

					printer:print_value(embed("t.", name), "");

					if static i < struct_.members.len - 1 {
						printer:print_chars(",");
					} else {
						printer:print_chars(" ");
					};
				};
				printer:print_chars("}");
			}
			case Tagged_Union |tagged_union_| {
				printer:print_chars(".{");

				for static tagged_union_.members |member| {
					var static name = member.name;
					if t is embed(name) |value| {
						printer:print_chars(name);

						printer:print_value(value, "");
						printer:print_chars(" ");
					};
				};

				printer:print_chars("}");
			}
			case Enum |enum_| {
				for static enum_.values |value| {
					if t == embed(value) {
						printer:print_chars(value);
					};
				};
			}
			case Optional {
				if t |value| {
					printer:print_value(value, "");
				} else {
					printer:print_chars("null");
				};
			}
			case Array |array| {
				printer:print_chars(".{");

				var static size = array.size;
				for static 0..size |i| {
					printer:print_chars(" ");

					printer:print_value(t[i], "");

					if i < size - 1 {
						printer:print_chars(",");
					} else {
						printer:print_chars(" ");
					};
				};

				printer:print_chars("}");
			}
			case Array_View |array_view| {
				if static fmt == "s" and array_view.type == byte {
					printer:print_chars(t);
				} else {
					printer:print_chars(".{");

					for 0..t.len |i| {
						printer:print_chars(" ");

						printer:print_value(t[i], "");

						if i < t.len - 1 {
							printer:print_chars(",");
						} else {
							printer:print_chars(" ");
						};
					};

					printer:print_chars("}");
				};
			}
		};
	};

	op print_char = fn (printer: ^Printer, char: byte) {
		printer.output_fn(null, char);
	};

	op print_chars = fn (printer: ^Printer, chars: []byte) {
		for chars |c| {
			printer.output_fn(null, c);
		};
	};
};
